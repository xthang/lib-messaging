/*
Copyright (C) 2023 Ready.io.
*/


#ifndef MESSAGING_FFI_H_
#define MESSAGING_FFI_H_

/* This file was automatically generated by cbindgen */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

typedef enum {
  MsgLogLevelError = 1,
  MsgLogLevelWarn,
  MsgLogLevelInfo,
  MsgLogLevelDebug,
  MsgLogLevelTrace,
} MsgLogLevel;

typedef enum {
  MsgErrorCodeUnknownError = 1,
  MsgErrorCodeInvalidState = 2,
  MsgErrorCodeInternalError = 3,
  MsgErrorCodeNullParameter = 4,
  MsgErrorCodeInvalidArgument = 5,
  MsgErrorCodeInvalidType = 6,
  MsgErrorCodeInvalidUtf8String = 7,
  MsgErrorCodeProtobufError = 10,
  MsgErrorCodeLegacyCiphertextVersion = 21,
  MsgErrorCodeUnknownCiphertextVersion = 22,
  MsgErrorCodeUnrecognizedMessageVersion = 23,
  MsgErrorCodeInvalidMessage = 30,
  MsgErrorCodeSealedSenderSelfSend = 31,
  MsgErrorCodeInvalidKey = 40,
  MsgErrorCodeInvalidSignature = 41,
  MsgErrorCodeInvalidAttestationData = 42,
  MsgErrorCodeFingerprintVersionMismatch = 51,
  MsgErrorCodeFingerprintParsingError = 52,
  MsgErrorCodeUntrustedIdentity = 60,
  MsgErrorCodeInvalidKeyIdentifier = 70,
  MsgErrorCodeSessionNotFound = 80,
  MsgErrorCodeInvalidRegistrationId = 81,
  MsgErrorCodeInvalidSession = 82,
  MsgErrorCodeInvalidSenderKeySession = 83,
  MsgErrorCodeDuplicatedMessage = 90,
  MsgErrorCodeCallbackError = 100,
  MsgErrorCodeVerificationFailure = 110,
  MsgErrorCodeUsernameCannotBeEmpty = 120,
  MsgErrorCodeUsernameCannotStartWithDigit = 121,
  MsgErrorCodeUsernameMissingSeparator = 122,
  MsgErrorCodeUsernameBadDiscriminator = 123,
  MsgErrorCodeUsernameBadCharacter = 124,
  MsgErrorCodeUsernameTooShort = 125,
  MsgErrorCodeUsernameTooLong = 126,
  MsgErrorCodeIoError = 130,
  MsgErrorCodeInvalidMediaInput = 131,
  MsgErrorCodeUnsupportedMediaInput = 132,
} MsgErrorCode;

typedef struct MsgPrivateKey MsgPrivateKey;

typedef struct MsgPublicKey MsgPublicKey;

/**
 * The top-level error type (opaquely) returned to C clients when something goes wrong.
 */
typedef struct MsgFfiError MsgFfiError;

typedef bool (*MsgLogEnabledCallback)(const char *target, MsgLogLevel level);

typedef void (*MsgLogCallback)(const char *target, MsgLogLevel level, const char *file, uint32_t line, const char *message);

typedef void (*MsgLogFlushCallback)(void);

typedef struct {
  MsgLogEnabledCallback enabled;
  MsgLogCallback log;
  MsgLogFlushCallback flush;
} MsgFfiLogger;

typedef struct {
  unsigned char *base;
  uintptr_t length;
} MsgOwnedBuffer;

typedef struct {
  const unsigned char *base;
  uintptr_t length;
} MsgBorrowedBuffer;

typedef struct {
  unsigned char *base;
  uintptr_t length;
} MsgBorrowedMutableBuffer;

void signal_print_ptr(const void *p);

void signal_free_string(const char *buf);

void signal_free_buffer(const unsigned char *buf, size_t buf_len);

MsgFfiError *signal_error_get_message(const MsgFfiError *err, const char **out);

uint32_t signal_error_get_type(const MsgFfiError *err);

void signal_error_free(MsgFfiError *err);

void signal_init_logger(MsgLogLevel max_level, MsgFfiLogger logger);

MsgFfiError *msg_aes256_cbc_encrypt(MsgOwnedBuffer *out, MsgBorrowedBuffer ptext, MsgBorrowedBuffer key, MsgBorrowedBuffer iv);

MsgFfiError *msg_aes256_cbc_decrypt(MsgOwnedBuffer *out, MsgBorrowedBuffer ptext, MsgBorrowedBuffer key, MsgBorrowedBuffer iv);

MsgFfiError *msg_privatekey_destroy(MsgPrivateKey *p);

MsgFfiError *msg_privatekey_clone(MsgPrivateKey **new_obj, const MsgPrivateKey *obj);

MsgFfiError *msg_publickey_destroy(MsgPublicKey *p);

MsgFfiError *msg_publickey_clone(MsgPublicKey **new_obj, const MsgPublicKey *obj);

MsgFfiError *msg_hkdf_derive(MsgBorrowedMutableBuffer output, MsgBorrowedBuffer ikm, MsgBorrowedBuffer label, MsgBorrowedBuffer salt);

MsgFfiError *msg_publickey_deserialize(MsgPublicKey **out, MsgBorrowedBuffer data);

MsgFfiError *msg_publickey_serialize(MsgOwnedBuffer *out, const MsgPublicKey *obj);

MsgFfiError *msg_publickey_get_public_key_bytes(MsgOwnedBuffer *out, const MsgPublicKey *obj);

MsgFfiError *msg_publickey_equals(bool *out, const MsgPublicKey *lhs, const MsgPublicKey *rhs);

MsgFfiError *msg_publickey_compare(int32_t *out, const MsgPublicKey *key1, const MsgPublicKey *key2);

MsgFfiError *msg_publickey_verify(bool *out, const MsgPublicKey *key, MsgBorrowedBuffer message, MsgBorrowedBuffer signature);

MsgFfiError *msg_privatekey_deserialize(MsgPrivateKey **out, MsgBorrowedBuffer data);

MsgFfiError *msg_privatekey_serialize(MsgOwnedBuffer *out, const MsgPrivateKey *obj);

MsgFfiError *msg_privatekey_generate(MsgPrivateKey **out);

MsgFfiError *msg_privatekey_get_public_key(MsgPublicKey **out, const MsgPrivateKey *k);

MsgFfiError *msg_privatekey_sign(MsgOwnedBuffer *out, const MsgPrivateKey *key, MsgBorrowedBuffer message);

MsgFfiError *msg_privatekey_agree(MsgOwnedBuffer *out, const MsgPrivateKey *private_key, const MsgPublicKey *public_key);

MsgFfiError *msg_compute_mac(MsgOwnedBuffer *out, MsgBorrowedBuffer mac_key, MsgBorrowedBuffer data);

MsgFfiError *msg_verify_mac(bool *out, MsgBorrowedBuffer mac_key, MsgBorrowedBuffer data, MsgBorrowedBuffer their_mac, uint32_t length);

#endif /* MESSAGING_FFI_H_ */
